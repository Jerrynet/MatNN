classdef Dropout < nn.layers.template.BaseLayer

    % Default parameters
    properties (SetAccess = protected, Transient)
        default_dropout_param = {
                    'name' {''}      ...  %empty names means use autogenerated name
            'enable_terms' true      ...
                    'rate' 0.5       ...
        };
    end
    properties
        mask;
    end

    methods
        function out = f(obj, in, mask)
            out = in.*mask;
        end
        function in_diff = b(obj, out_diff, mask)
            in_diff = out_diff.*mask;
        end
        function forward(obj)
            data = obj.net.data;
            opts = obj.net.opts;

            btm = data.val{obj.bottom(1)};

            p = obj.params.dropout;
            if opts.disableDropout || ~p.enable_terms
                top = btm;
            elseif opts.freezeDropout && numel(btm) == numel(data.val{obj.mask})
                top = btm.*data.val{obj.mask};
            else
                if opts.gpu
                    m = single(1 / (1 - p.rate)) .* (gpuArray.rand(size(btm),'single') >= p.rate);
                    top = btm .* m;
                else
                    m = single(1 / (1 - p.rate)) .* (rand(size(btm),'single') >= p.rate);
                    top = btm .* m;
                end
                data.val{obj.mask} = m;
            end
            data.val{obj.top} = top;
            data.forwardCount(obj.bottom, obj.top);
            data.forwardCount(obj.mask, []);
        end
        function backward(obj)
            data = obj.net.data;
            opts = obj.net.opts;

            if opts.disableDropout || ~obj.params.dropout.enable_terms
                bottom_diff = data.diff{obj.top};
            else
                bottom_diff = data.diff{obj.top} .* data.val{obj.mask};
            end
            data.backwardCount(obj.bottom,  obj.top, bottom_diff);
            data.backwardCount(obj.mask, [], []);
        end
        function createResources(obj, inSizes)
            p = obj.params.dropout;
            data = obj.net.data;
            if isempty(p.name{1})
                maskName = [obj.name, '_mask'];
            else
                maskName = p.name{1};
            end
            obj.mask = maskName;
            if p.enable_terms
                scale = single(1 / (1 - p.rate)) ;
                data.setPartial(maskName,      'val', scale.* single(rand(inSizes{1}) >= p.rate), ...
                                          'preserve', true);
                if obj.net.opts.gpu
                    data.val{obj.mask} = gpuArray(obj.net.data.val{obj.mask});
                end
            end
        end
        function setParams(obj)
            obj.setParams@nn.layers.template.BaseLayer();
            p = obj.params.dropout;
            assert(p.rate >= 0 && p.rate <=1);
        end
        function outSizes = setup(obj, inSizes)
            outSizes = obj.setup@nn.layers.template.BaseLayer(inSizes);
            assert(numel(obj.bottom)==1);
            assert(numel(obj.top)==1);
        end
        function set.mask(obj, val)
            obj.mask = obj.connectData('mask', val, true);
        end
        function release(obj)
            obj.top = [];
            obj.bottom = [];
            obj.mask = [];
        end
        function vars = holdVars(obj)
            vars = [obj.bottom, obj.top, obj.mask];
        end
        function v = propertyDevice(obj)
            v = obj.propertyDevice@nn.layers.template.BaseLayer();
            v.mask = -1;
        end
    end
end