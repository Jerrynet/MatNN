function o = affine(networkParameter)
%AFFINE Affine transformation

o.name         = 'Affine';
o.generateLoss = false;
o.setup        = @setup;
o.forward      = @forward;
o.backward     = @backward;
o.outputSize   = [];


default_weight_param = {
               'name' {''}       ... %empty names means use autogenerated name
          'generator' {@nn.generator.gaussian} ...
    'generator_param' {[]}   ... %default param
       'enable_terms' [true]     ... % if false, second input will applied as weight
       'learningRate' single(1)    ...
        'weightDecay' single(1)
};

default_affine_param = {
    'sampler' 'bilinear' ... % currently only support bilinear interpolation
    'showDebugWindow' false ...
};

af = [];
ab = [];
c = 0;
    function [resource, topSizes, param] = setup(l, bottomSizes)
        % resource only have .weight
        % if you have other outputs you want to save or share
        % you can set its learning rate to zero to prevent update


        if isfield(l, 'weight_param')
            wp1 = nn.utils.vararginHelper(default_weight_param, l.weight_param);
        else
            wp1 = nn.utils.vararginHelper(default_weight_param, default_weight_param);
        end
        if isfield(l, 'affine_param')
            wp2 = nn.utils.vararginHelper(default_affine_param, l.affine_param);
        else
            wp2 = nn.utils.vararginHelper(default_affine_param, default_affine_param);
        end

        if wp1.enable_terms
            assert(numel(l.bottom)==1);
        else
            assert(numel(l.bottom)==2);
            assert(bottomSizes{2}(1) == 1 && bottomSizes{2}(2) == 1 && bottomSizes{2}(3) == 6 && bottomSizes{2}(4) == bottomSizes{1}(4));
        end

        assert(numel(l.top)==1);
        assert(strcmpi(wp2.sampler, 'bilinear'));



        resource.weight = {[]};
        topSizes = @(x) x(1);

        if wp1.enable_terms
            resource.weight{1} = wp1.generator{1}([1, 1, 6, bottomSizes{1}(4)], wp1.generator_param{1});
        end

        if numel(networkParameter.gpus)>0
            ptxp = which('affine.ptx');
            cup  = which('affine.cu');
            af = nn.utils.gpu.createHandle(prod(bottomSizes{1}), ptxp, cup, 'AffineForward');
            ab = nn.utils.gpu.createHandle(prod(bottomSizes{1}), ptxp, cup, 'AffineBackward');
        else
            error('Affine Layer runs on GPU (currently).');
        end

        %return updated param
        param.weight_param = wp1;
        param.affine_param = wp2;
    end


    function [top, weights, misc] = forward(opts, l, weights, misc, bottom, top)
        top{1} = bottom{1}.*0;
        s = nn.utils.size4D(bottom{1});
        len = prod(s);
        if opts.gpuMode
            if l.weight_param.enable_terms
                top{1} = feval(af, bottom{1}, s, weights{1}, len, top{1});
            else
                top{1} = feval(af, bottom{1}, s, bottom{2}, len, top{1});
            end
        else
            if l.weight_param.enable_terms
                %...
            else
                %...
            end
        end

        if l.affine_param.showDebugWindow
            if mod(c, 20) == 0
                t = gather(bottom{2}(:,:,:,1));
                o1 = trans(t, [1,1]      , s(1:2));
                o2 = trans(t, [s(1),1]   , s(1:2));
                o3 = trans(t, [s(1),s(2)], s(1:2));
                o4 = trans(t, [1,s(2)]   , s(1:2));
                ox = [o1(2),o2(2),o3(2),o4(2)];
                oy = [o1(1),o2(1),o3(1),o4(1)];

                subplot(1,2,1), imshow(gather(bottom{1}(:,:,:,1)), []), ...
                                line(ox(1:2), oy(1:2), 'LineWidth',4,'Color','r'), ...
                                line(ox(2:3), oy(2:3), 'LineWidth',4,'Color','g'), ...
                                line(ox(3:4), oy(3:4), 'LineWidth',4,'Color','b'), ...
                                line(ox([4,1]), oy([4,1]), 'LineWidth',4,'Color','y');
                set(gca,'Clipping','off');
                subplot(1,2,2), imshow(gather(top{1}(:,:,:,1)), []);
                drawnow;
                c = 0;
            end
            c = c+1;
        end

        function o = trans(a,o,s) % p = [y,x], s = [h,w]
            p = 2*((o./s)-0.5);
            o(2) = a(1)*p(2) + a(3)*p(1) + a(5);
            o(1) = a(2)*p(2) + a(4)*p(1) + a(6);
            o = (o./2+0.5).*s;
        end
    end


    function [bottom_diff, weights_diff, misc] = backward(opts, l, weights, misc, bottom, top, top_diff, weights_diff)
        %numel(bottom_diff) = numel(bottom), numel(weights_diff) = numel(weights)

        bottom_diff{1} = top_diff{1}.*0;
        s = nn.utils.size4D(top_diff{1});
        len = prod(s);
        if opts.gpuMode
            if l.weight_param.enable_terms
                weights_diff{1} = weights{1}.*0;
                [bottom_diff{1}, weights_diff{1}] = feval(ab, bottom{1}, s, weights{1}, len, top{1}, top_diff{1}, bottom_diff{1}, weights_diff{1});
            else
                bottom_diff{2} = bottom{2}.*0;
                [bottom_diff{1}, bottom_diff{2}] = feval(ab, bottom{1}, s, bottom{2}, len, top{1}, top_diff{1}, bottom_diff{1}, bottom_diff{2});
            end
        else
            %...
        end

    end

end
