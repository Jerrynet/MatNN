function mnist_siamese()

conf = nn.examples.config();
trainer = nn.nn('MNIST_Siamese');
batchSize = 100;

% ================================================ twins 1
trainer.add({
    'type' 'data.MNIST'...
    'name' 'data'...
    'top' {'data', 'label'} ...
    'data_param' {
                'src' conf.mnistPath ...
        'root_folder' ''       ...
         'batch_size' batchSize ...
               'full' false  ...
            'shuffle' true   ...
        } ...
    'mnist_param' {
           'type' 'train' ...
        }
    });
trainer.add({
    'type'   'Conv'...
    'name'   'conv1'...
    'bottom' 'data' ...
    'top'    'conv1'...
    'conv_param' {
        'num_output'  20 ...
        'kernel_size' 5  ...
        'pad'         0  ...
        'stride'      1  ...
        }...
    'weight_param' {
        'name'         {'conv1_w1', 'conv1_b1'} ...
        'generator'   {@nn.generator.gaussian, @nn.generator.constant} ...
        'generator_param' {{'mean', 0, 'std', 0.01}, []} ...
        'learningRate' [1 2]
        }
    });
trainer.add({
    'type'   'Pooling'...
    'name'   'pool1'...
    'bottom' 'conv1'...
    'top'    'pool1'...
    'pooling_param' {
        'method'      'max' ...
        'kernel_size' 2  ...
        'pad'         0  ...
        'stride'      2  ...
        }...
    });
trainer.add({
    'type'   'Conv'...
    'name'   'conv2'...
    'bottom' 'pool1' ...
    'top'    'conv2'...
    'conv_param' {
        'num_output'  50 ...
        'kernel_size' 5  ...
        'pad'         0  ...
        'stride'      1  ...
        }...
    'weight_param' {
        'name'         {'conv2_w1', 'conv2_b1'} ...
        'generator'   {@nn.generator.gaussian, @nn.generator.constant} ...
        'generator_param' {{'mean', 0, 'std', 0.01}, []} ...
        'learningRate' [1 2]
        }
    });
trainer.add({
    'type'   'Pooling'...
    'name'   'pool2'...
    'bottom' 'conv2'...
    'top'    'pool2'...
    'pooling_param' {
        'method'      'max' ...
        'kernel_size' 2  ...
        'pad'         0  ...
        'stride'      2  ...
        }...
    });
trainer.add({
    'type'   'Conv'...
    'name'   'conv3'...
    'bottom' 'pool2' ...
    'top'    'conv3'...
    'conv_param' {
        'num_output'  500 ...
        'kernel_size' 4  ...
        'pad'         0  ...
        'stride'      1  ...
        }...
    'weight_param' {
        'name'         {'conv3_w1', 'conv3_b1'} ...
        'generator'   {@nn.generator.gaussian, @nn.generator.constant} ...
        'generator_param' {{'mean', 0, 'std', 0.01}, []} ...
        'learningRate' [1 2]
        }
    });
trainer.add({
    'type'   'ReLU'...
    'name'   'relu1'...
    'bottom' 'conv3'...
    'top'    'relu1'...
    });
trainer.add({
    'type'   'Conv'...
    'name'   'fc4'...
    'bottom' 'relu1' ...
    'top'    'fc4'...
    'conv_param' {
        'num_output'  10 ...
        'kernel_size' 1  ...
        'pad'         0  ...
        'stride'      1  ...
        }...
    'weight_param' {
        'name'         {'fc4_w1', 'fc4_b1'} ...
        'generator'   {@nn.generator.gaussian, @nn.generator.constant} ...
        'generator_param' {{'mean', 0, 'std', 0.01}, []} ...
        'learningRate' [1 2]
        }
    });
trainer.add({
    'type'   'Conv'...
    'name'   'feat'...
    'bottom' 'fc4' ...
    'top'    'feat'...
    'conv_param' {
        'num_output'  2 ...
        'kernel_size' 1  ...
        'pad'         0  ...
        'stride'      1  ...
        }...
    'weight_param' {
        'name'         {'feat_w1', 'feat_b1'} ...
        'generator'   {@nn.generator.gaussian, @nn.generator.constant} ...
        'generator_param' {{'mean', 0, 'std', 0.01}, []} ...
        'learningRate' [1 2]
        }
    });

% ================================================ twins 2
trainer.add({
    'type' 'data.MNIST'...
    'name' 'datap'...
    'top' {'datap', 'labelp'} ...
    'data_param' {
                'src' conf.mnistPath ...
        'root_folder' ''       ...
         'batch_size' batchSize ...
               'full' false  ...
            'shuffle' true   ...
        } ...
    'mnist_param' {
           'type' 'train' ...
        }
    });
trainer.add({
    'type'   'Conv'...
    'name'   'conv1p'...
    'bottom' 'datap' ...
    'top'    'conv1p'...
    'conv_param' {
        'num_output'  20 ...
        'kernel_size' 5  ...
        'pad'         0  ...
        'stride'      1  ...
        }...
    'weight_param' {
        'name'         {'conv1_w1', 'conv1_b1'} ...
        'generator'   {@nn.generator.gaussian, @nn.generator.constant} ...
        'generator_param' {{'mean', 0, 'std', 0.01}, []} ...
        'learningRate' [1 2]
        }
    });
trainer.add({
    'type'   'Pooling'...
    'name'   'pool1p'...
    'bottom' 'conv1p'...
    'top'    'pool1p'...
    'pooling_param' {
        'method'      'max' ...
        'kernel_size' 2  ...
        'pad'         0  ...
        'stride'      2  ...
        }...
    });
trainer.add({
    'type'   'Conv'...
    'name'   'conv2p'...
    'bottom' 'pool1p' ...
    'top'    'conv2p'...
    'conv_param' {
        'num_output'  50 ...
        'kernel_size' 5  ...
        'pad'         0  ...
        'stride'      1  ...
        }...
    'weight_param' {
        'name'         {'conv2_w1', 'conv2_b1'} ...
        'generator'   {@nn.generator.gaussian, @nn.generator.constant} ...
        'generator_param' {{'mean', 0, 'std', 0.01}, []} ...
        'learningRate' [1 2]
        }
    });
trainer.add({
    'type'   'Pooling'...
    'name'   'pool2p'...
    'bottom' 'conv2p'...
    'top'    'pool2p'...
    'pooling_param' {
        'method'      'max' ...
        'kernel_size' 2  ...
        'pad'         0  ...
        'stride'      2  ...
        }...
    });
trainer.add({
    'type'   'Conv'...
    'name'   'conv3p'...
    'bottom' 'pool2p' ...
    'top'    'conv3p'...
    'conv_param' {
        'num_output'  500 ...
        'kernel_size' 4  ...
        'pad'         0  ...
        'stride'      1  ...
        }...
    'weight_param' {
        'name'         {'conv3_w1', 'conv3_b1'} ...
        'generator'   {@nn.generator.gaussian, @nn.generator.constant} ...
        'generator_param' {{'mean', 0, 'std', 0.01}, []} ...
        'learningRate' [1 2]
        }
    });
trainer.add({
    'type'   'ReLU'...
    'name'   'relu1p'...
    'bottom' 'conv3p'...
    'top'    'relu1p'...
    });
trainer.add({
    'type'   'Conv'...
    'name'   'fc4p'...
    'bottom' 'relu1p' ...
    'top'    'fc4p'...
    'conv_param' {
        'num_output'  10 ...
        'kernel_size' 1  ...
        'pad'         0  ...
        'stride'      1  ...
        }...
    'weight_param' {
        'name'         {'fc4_w1', 'fc4_b1'} ...
        'generator'   {@nn.generator.gaussian, @nn.generator.constant} ...
        'generator_param' {{'mean', 0, 'std', 0.01}, []} ...
        'learningRate' [1 2]
        }
    });
trainer.add({
    'type'   'Conv'...
    'name'   'featp'...
    'bottom' 'fc4p' ...
    'top'    'featp'...
    'conv_param' {
        'num_output'  2  ...
        'kernel_size' 1  ...
        'pad'         0  ...
        'stride'      1  ...
        }...
    'weight_param' {
        'name'         {'feat_w1', 'feat_b1'} ...
        'generator'   {@nn.generator.gaussian, @nn.generator.constant} ...
        'generator_param' {{'mean', 0, 'std', 0.01}, []} ...
        'learningRate' [1 2]
        }
    });

% =========================================
trainer.add({
    'type'   'Equal'...
    'name'   'sim'...
    'bottom' {'label', 'labelp'} ...
    'top'    'sim'...
    });
trainer.add({
    'type'   'loss.ContrastiveLoss'...
    'name'   'loss'...
    'bottom' {'feat', 'featp', 'sim'}...
    'top'    'loss' ...
    'loss_param' {
              'threshold' single(1e-5) ...
             'accumulate' true  ... 
            'loss_weight' single(1) ... 
        }
    });

trainer.flowOrder = {'train'};
trainer.repeat    = 10;
trainer.savePath  = fullfile('data','exp');
trainer.gpu       = 1;

trainOp.iter               = 5000;  
trainOp.numToSave          = 500*conf.save;  
trainOp.displayIter        = 100;
trainOp.learningRateSteps  = 5000;
trainOp.learningRatePolicy = @lrPolicy;
trainOp.learningRate       = 0.01;
trainOp.learningRateGamma  = 0.0001;
trainOp.learningRatePower  = 0.75;

trainLayers = trainer.getLayerIDs('data', 'conv1', 'pool1', 'conv2', 'pool2', 'conv3', 'relu1', 'fc4', 'feat',  ...
                                  'datap','conv1p','pool1p','conv2p','pool2p','conv3p','relu1p','fc4p','featp', ...
                                  'sim',   'loss');
trainer.addFlow('train', trainOp, trainLayers);

trainer.run();

end

function res = lrPolicy(globalIterNum, currentPhaseTotalIter, lr, gamma, power, steps)
     res = lr*((1+gamma*(currentPhaseTotalIter-1))^(-power));
end