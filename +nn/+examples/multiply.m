function multiply()

trainer = nn.nn('Multiply');
inputData1 = {ones(3,3,3,3)};
inputData1{1}(1) = 10;

inputData2 = {ones(3,3,3,3)};
inputData2{1}(1) = 20;

targetData = {ones(3,3,3,3)};

trainer.add({
    'type' 'data.Replicate'  ...
    'name' 'data1'  ...
    'top'  {'data1'}  ...
    'data_param' {
        'src' ''  ...
        'root_folder' ''  ...
        'batch_size' []  ...
               'full' false  ...
            'shuffle' false  ...
        } ...
    'replicate_param' {
           'value' inputData1  ...
        } ...
    });
trainer.add({
    'type' 'data.Replicate'  ...
    'name' 'data2'  ...
    'top'  {'data2'}  ...
    'data_param' {
        'src' ''  ...
        'root_folder' ''  ...
        'batch_size' []  ...
               'full' false  ...
            'shuffle' false  ...
        } ...
    'replicate_param' {
           'value' inputData2  ...
        } ...
    });
trainer.add({
    'type' 'data.Replicate'  ...
    'name' 'target'  ...
    'top'  {'target'}  ...
    'data_param' {
        'src' ''  ...
        'root_folder' ''  ...
        'batch_size' []  ...
               'full' false  ...
            'shuffle' false  ...
        } ...
    'replicate_param' {
           'value' targetData  ...
        } ...
    });
trainer.add({
    'type'   'Multiply'  ...
    'name'   'multiply'  ...
    'bottom' {'data1', 'data2'}  ...
    'top'    'multiply'  ...
    'multiply_param' {
        'transpose' false  ...
        }  ...
    })
trainer.add({
    'type'   'loss.EuclideanLoss'  ...
    'name'   'loss'  ...
    'bottom' {'multiply', 'target'}  ...
    'top'    'loss'  ...
    });


trainer.flowOrder = {'test'};
trainer.repeat    = 1;
trainer.savePath  = fullfile('data','exp');
trainer.gpu       = 1;

testOp.iter          = 500;
testOp.numToSave     = [];
testOp.displayIter   = 100;
testOp.showFirstIter = false;
testOp.learningRate  = 1;

testLayers = trainer.getLayerIDs('data1', 'data2', 'target', 'multiply', 'loss');
trainer.addFlow('test', testOp, testLayers);

trainer.run();

end

function res = lrPolicy(globalIterNum, currentPhaseTotalIter, lr, gamma, power, steps)
     res = lr*(gamma^floor((currentPhaseTotalIter-1)/steps));
end

